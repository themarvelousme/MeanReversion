"""
Enhanced mean reversion analyzer with Celery task integration
Handles output formatting, file I/O, database operations, and orchestrates the analysis
"""
import csv
import sys
import logging
import asyncio
from datetime import datetime
from typing import List, Dict, Any, Optional
import time

from data_models import MeanReversionSignal, TradingRecommendation
from mean_reversion_detector import EnhancedMeanReversionDetector

# Import Celery tasks
try:
    from tasks import (
        create_or_update_stock, save_stock_analysis, bulk_save_analyses,
        get_latest_analysis, get_analyses_by_condition, get_high_confidence_recommendations,
        get_stock_history, cleanup_old_analyses, get_database_stats
    )
    CELERY_AVAILABLE = True
except ImportError:
    print("Warning: Celery tasks not available. Database operations will be disabled.")
    CELERY_AVAILABLE = False


class CeleryEnabledMeanReversionAnalyzer:
    """
    Enhanced analyzer class that integrates with Celery for database operations
    """
    
    def __init__(self, output_filename: str = None, enable_db: bool = True):
        """
        Initialize the analyzer
        
        Args:
            output_filename: File to write detailed output (if None, autogenerated)
            enable_db: Whether to enable database operations via Celery
        """
        self.detector = EnhancedMeanReversionDetector()
        self.enable_db = enable_db and CELERY_AVAILABLE
        
        if output_filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            self.output_filename = f"mean_reversion_output_{timestamp}.txt"
        else:
            self.output_filename = output_filename
        
        # Track task results
        self.db_tasks = []
        self.task_results = {}
    
    def run_analysis(self, stock_file: str = None, custom_symbols: List[str] = None, 
                    show_progress: bool = True, save_csv: bool = True,
                    save_to_db: bool = True) -> List[MeanReversionSignal]:
        """
        Run the complete mean reversion analysis with database integration
        
        Args:
            stock_file: Path to file containing stock symbols
            custom_symbols: List of custom stock symbols
            show_progress: Whether to show progress bar
            save_csv: Whether to save summary CSV file
            save_to_db: Whether to save results to database via Celery
            
        Returns:
            List of mean reversion signals
        """
        print("Starting Enhanced Mean Reversion Analysis with Celery Integration...")
        print(f"Analysis will be saved to: {self.output_filename}")
        print(f"Database operations: {'Enabled' if self.enable_db and save_to_db else 'Disabled'}")
        
        # Run the market scan
        signals = self.detector.scan_market(
            stock_file=stock_file, 
            custom_symbols=custom_symbols, 
            show_progress=show_progress
        )
        
        # Save to database if enabled
        if self.enable_db and save_to_db and signals:
            print("Saving results to database...")
            self.save_to_database(signals)
        
        # Generate detailed results
        self.print_detailed_results(signals, show_recommendations=True)
        
        # Save summary CSV if requested
        if save_csv:
            csv_filename = f"summary_output_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
            self.save_results_to_file(signals, csv_filename)
            print(f"Summary CSV saved to: {csv_filename}")
        
        # Print summary to console
        self.print_console_summary(signals)
        
        return signals
    
    def save_to_database(self, signals: List[MeanReversionSignal]) -> Dict[str, Any]:
        """
        Save analysis results to database using Celery tasks
        """
        if not self.enable_db:
            print("Database operations disabled")
            return {}
        
        # First, create/update stock records
        stock_tasks = []
        for signal in signals:
            task = create_or_update_stock.delay(
                symbol=signal.symbol,
                name=None,  # Could be enhanced to fetch company names
                sector=signal.sector,
                market_cap_category=signal.market_cap
            )
            stock_tasks.append((signal.symbol, task))
        
        # Wait for stock creation/updates to complete
        print("Creating/updating stock records...")
        for symbol, task in stock_tasks:
            try:
                result = task.get(timeout=30)
                print(f"✓ Stock {symbol}: {result['action']}")
            except Exception as e:
                print(f"✗ Failed to process stock {symbol}: {e}")
        
        # Prepare analysis data for bulk save
        analyses_data = []
        for signal in signals:
            # Generate recommendation
            recommendation = self.detector.generate_trading_recommendation(signal)
            
            analysis_data = {
                'symbol': signal.symbol,
                'analysis': {
                    'current_price': float(signal.current_price),
                    'mean_price': float(signal.mean_price),
                    'price_deviation_percent': float((signal.current_price / signal.mean_price - 1) * 100),
                    'z_score': float(signal.z_score),
                    'rsi': float(signal.rsi),
                    'bollinger_position': float(signal.bollinger_position),
                    'volatility_percent': float(signal.volatility),
                    'volume_ratio': float(signal.volume_ratio),
                    'five_day_change_percent': float(signal.price_change_5d),
                    'hurst_exponent': float(signal.hurst_exponent),
                    'strength_rating': signal.reversion_strength,
                    'market_condition': 'OVERSOLD' if signal.is_oversold else 'OVERBOUGHT' if signal.is_overbought else 'NEUTRAL'
                },
                'recommendation': {
                    'action': recommendation.action,
                    'confidence_level': recommendation.confidence,
                    'time_horizon': recommendation.time_horizon,
                    'entry_criteria': recommendation.entry_criteria,
                    'exit_criteria': recommendation.exit_criteria,
                    'risk_factors': recommendation.risk_factors,
                    'educational_notes': '\n'.join(recommendation.educational_notes)
                }
            }
            analyses_data.append(analysis_data)
        
        # Save analyses in bulk
        print("Saving analysis results...")
        bulk_task = bulk_save_analyses.delay(analyses_data)
        
        try:
            result = bulk_task.get(timeout=120)
            print(f"✓ Bulk save completed: {result['queued']} queued, {result['errors']} errors")
            return result
        except Exception as e:
            print(f"✗ Bulk save failed: {e}")
            return {'error': str(e)}
    
    def get_database_summary(self) -> Dict[str, Any]:
        """
        Get database statistics
        """
        if not self.enable_db:
            return {'error': 'Database operations disabled'}
        
        try:
            stats_task = get_database_stats.delay()
            stats = stats_task.get(timeout=30)
            return stats
        except Exception as e:
            return {'error': str(e)}
    
    def get_latest_stock_analysis(self, symbol: str) -> Dict[str, Any]:
        """
        Get latest analysis for a specific stock
        """
        if not self.enable_db:
            return {'error': 'Database operations disabled'}
        
        try:
            task = get_latest_analysis.delay(symbol)
            result = task.get(timeout=30)
            return result
        except Exception as e:
            return {'error': str(e)}
    
    def get_signals_by_condition(self, condition: str, limit: int = 50) -> List[Dict[str, Any]]:
        """
        Get signals by market condition (OVERSOLD, OVERBOUGHT, NEUTRAL)
        """
        if not self.enable_db:
            return []
        
        try:
            task = get_analyses_by_condition.delay(condition, limit)
            results = task.get(timeout=30)
            return results
        except Exception as e:
            print(f"Error getting signals by condition: {e}")
            return []
    
    def get_high_confidence_signals(self, confidence: str = 'HIGH', limit: int = 50) -> List[Dict[str, Any]]:
        """
        Get high confidence trading recommendations
        """
        if not self.enable_db:
            return []
        
        try:
            task = get_high_confidence_recommendations.delay(confidence, limit)
            results = task.get(timeout=30)
            return results
        except Exception as e:
            print(f"Error getting high confidence signals: {e}")
            return []
    
    def get_stock_analysis_history(self, symbol: str, days: int = 30) -> List[Dict[str, Any]]:
        """
        Get analysis history for a stock
        """
        if not self.enable_db:
            return []
        
        try:
            task = get_stock_history.delay(symbol, days)
            results = task.get(timeout=30)
            return results
        except Exception as e:
            print(f"Error getting stock history: {e}")
            return []
    
    def cleanup_old_data(self, days_to_keep: int = 90) -> Dict[str, int]:
        """
        Clean up old analysis data
        """
        if not self.enable_db:
            return {'error': 'Database operations disabled'}
        
        try:
            task = cleanup_old_analyses.delay(days_to_keep)
            result = task.get(timeout=60)
            return result
        except Exception as e:
            return {'error': str(e)}
    
    def print_database_summary(self):
        """
        Print database statistics
        """
        print("\n" + "="*80)
        print("DATABASE SUMMARY")
        print("="*80)
        
        stats = self.get_database_summary()
        
        if 'error' in stats:
            print(f"Error: {stats['error']}")
            return
        
        print(f"Total Stocks: {stats.get('total_stocks', 0)}")
        print(f"Total Analyses: {stats.get('total_analyses', 0)}")
        print(f"Total Recommendations: {stats.get('total_recommendations', 0)}")
        print(f"Latest Analysis: {stats.get('latest_analysis', 'N/A')}")
        
        recent_conditions = stats.get('recent_conditions', {})
        if recent_conditions:
            print("\nRecent Market Conditions (Last 7 days):")
            for condition, count in recent_conditions.items():
                print(f"  {condition}: {count}")
        
        print("="*80)
    
    def print_console_summary(self, signals: List[MeanReversionSignal]):
        """Print a brief summary to console"""
        if not signals:
            print("\nNo mean reversion signals found.")
            return
        
        print(f"\n{'='*80}")
        print(f"ANALYSIS SUMMARY - Found {len(signals)} signals")
        print(f"{'='*80}")
        
        # Count by strength
        strength_counts = {}
        oversold_count = 0
        overbought_count = 0
        
        for signal in signals:
            strength = signal.reversion_strength
            strength_counts[strength] = strength_counts.get(strength, 0) + 1
            
            if signal.is_oversold:
                oversold_count += 1
            elif signal.is_overbought:
                overbought_count += 1
        
        print(f"Signal Strength Distribution:")
        for strength in ["Strong", "Moderate", "Weak", "None"]:
            count = strength_counts.get(strength, 0)
            print(f"  {strength}: {count}")
        
        print(f"\nSignal Types:")
        print(f"  Oversold: {oversold_count}")
        print(f"  Overbought: {overbought_count}")
        print(f"  Neutral: {len(signals) - oversold_count - overbought_count}")
        
        # Show top 5 strongest signals
        strength_order = {"Strong": 3, "Moderate": 2, "Weak": 1, "None": 0}
        top_signals = sorted(signals, 
                           key=lambda x: (strength_order.get(x.reversion_strength, 0), abs(x.z_score)), 
                           reverse=True)[:5]
        
        print(f"\nTop 5 Strongest Signals:")
        print(f"{'Symbol':<8} {'Strength':<10} {'Z-Score':<8} {'RSI':<6} {'Type':<12}")
        print(f"{'-'*50}")
        
        for signal in top_signals:
            signal_type = "OVERSOLD" if signal.is_oversold else "OVERBOUGHT" if signal.is_overbought else "NEUTRAL"
            print(f"{signal.symbol:<8} {signal.reversion_strength:<10} {signal.z_score:<8.2f} {signal.rsi:<6.1f} {signal_type:<12}")
        
        print(f"\nDetailed analysis saved to: {self.output_filename}")
        
        # Print database summary if enabled
        if self.enable_db:
            self.print_database_summary()
        
        print(f"{'='*80}")
    
    def print_detailed_results(self, signals: List[MeanReversionSignal], show_recommendations: bool = True):
        """
        Write detailed analysis results and trading recommendations to the output file
        """
        if not signals:
            with open(self.output_filename, 'w') as f:
                f.write("No mean reversion signals found.\n")
            self.detector.logger.info("No mean reversion signals found.")
            return
        
        with open(self.output_filename, 'w') as f:
            f.write(f"\n{'='*100}\n")
            f.write(f"ENHANCED MEAN REVERSION ANALYSIS RESULTS ({len(signals)} signals)\n")
            f.write(f"Analysis Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"Database Integration: {'Enabled' if self.enable_db else 'Disabled'}\n")
            f.write(f"{'='*100}\n")
            
            strength_order = {"Strong": 3, "Moderate": 2, "Weak": 1, "None": 0}
            sorted_signals = sorted(signals, 
                                  key=lambda x: (strength_order.get(x.reversion_strength, 0), abs(x.z_score)), 
                                  reverse=True)
            
            for i, signal in enumerate(sorted_signals):
                f.write(f"\n{'-'*100}\n")
                f.write(f"#{i+1}: {signal.symbol} ({signal.sector} - {signal.market_cap})\n")
                f.write(f"{'-'*100}\n")
                f.write(f"Price: ${signal.current_price:>8.2f} | Mean: ${signal.mean_price:>8.2f} | Deviation: {((signal.current_price/signal.mean_price-1)*100):>+6.1f}%\n")
                f.write(f"Z-Score: {signal.z_score:>6.2f} | RSI: {signal.rsi:>5.1f} | BB Position: {signal.bollinger_position:>5.2f}\n")
                f.write(f"Volatility: {signal.volatility:>5.1f}% | Volume Ratio: {signal.volume_ratio:>4.1f}x | 5d Change: {signal.price_change_5d:>+6.1f}%\n")
                f.write(f"Strength: {signal.reversion_strength:>8} | {'OVERSOLD' if signal.is_oversold else 'OVERBOUGHT' if signal.is_overbought else 'NEUTRAL':>10} | Hurst: {signal.hurst_exponent:>5.2f}\n")
                
                if show_recommendations:
                    recommendation = self.detector.generate_trading_recommendation(signal)
                    f.write(f"\nTRADING RECOMMENDATION:\n")
                    f.write(f"Action: {recommendation.action} | Confidence: {recommendation.confidence} | Horizon: {recommendation.time_horizon}\n")
                    
                    if recommendation.action in ["BUY_PUTS", "BUY_CALLS"]:
                        f.write(f"\nEntry Criteria:\n")
                        for criteria in recommendation.entry_criteria:
                            f.write(f"  • {criteria}\n")
                        
                        f.write(f"\nExit Criteria:\n")
                        for criteria in recommendation.exit_criteria:
                            f.write(f"  • {criteria}\n")
                        
                        f.write(f"\nRisk Factors:\n")
                        for risk in recommendation.risk_factors:
                            f.write(f"  ⚠ {risk}\n")
                        
                        f.write(f"\nEducational Notes:\n")
                        for note in recommendation.educational_notes:
                            f.write(f"  - {note}\n")
                    
                    f.write("\n" + ("-"*100) + "\n")
        
        self.detector.logger.info(f"Detailed results written to {self.output_filename}")
    
    def save_results_to_file(self, signals: List[MeanReversionSignal], filename: str):
        """Save summary results to CSV file"""
        if not signals:
            self.detector.logger.warning("No signals to save.")
            return
        
        with open(filename, 'w', newline='') as csvfile:
            fieldnames = [
                'Symbol', 'Current Price', 'Mean Price', 'Std Dev', 'Z-Score', 'RSI', 'Bollinger Position',
                'Oversold', 'Overbought', 'Reversion Strength', 'Days From Mean', 'ADF p-value', 'Hurst Exponent',
                'Volume Ratio', '5d Price Change %', 'Volatility %', 'Market Cap', 'Sector'
            ]
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            
            for s in signals:
                writer.writerow({
                    'Symbol': s.symbol,
                    'Current Price': round(s.current_price, 4),
                    'Mean Price': round(s.mean_price, 4),
                    'Std Dev': round(s.std_dev, 4),
                    'Z-Score': round(s.z_score, 4),
                    'RSI': round(s.rsi, 2),
                    'Bollinger Position': round(s.bollinger_position, 4),
                    'Oversold': s.is_oversold,
                    'Overbought': s.is_overbought,
                    'Reversion Strength': s.reversion_strength,
                    'Days From Mean': s.days_from_mean,
                    'ADF p-value': round(s.adf_pvalue, 6),
                    'Hurst Exponent': round(s.hurst_exponent, 4),
                    'Volume Ratio': round(s.volume_ratio, 2),
                    '5d Price Change %': round(s.price_change_5d, 2),
                    'Volatility %': round(s.volatility, 2),
                    'Market Cap': s.market_cap,
                    'Sector': s.sector
                })
        
        self.detector.logger.info(f"Summary results saved to {filename}")
    
    def create_sample_files(self):
        """Create sample input files for users"""
        self.detector.create_sample_stock_file("sample_stocks.csv")
        print("Sample stock list created: sample_stocks.csv")


def main():
    """
    Main entry point for the analysis script with Celery integration
    """
    # Parse command line arguments
    if len(sys.argv) < 2:
        print("Usage: python celery_analyzer.py <stock_list.csv> [options]")
        print("\nOptions:")
        print("  --create-sample : Create a sample stock list file")
        print("  --no-progress   : Disable progress bar")
        print("  --no-csv        : Don't save summary CSV file")
        print("  --no-db         : Disable database operations")
        print("  --db-stats      : Show database statistics only")
        print("  --cleanup-db    : Clean up old database records")
        print("  --get-latest <SYMBOL> : Get latest analysis for symbol")
        print("  --get-oversold  : Get oversold signals from database")
        print("  --get-overbought: Get overbought signals from database")
        print("  --get-high-conf : Get high confidence recommendations")
        print("\nExample:")
        print("  python celery_analyzer.py my_stocks.csv")
        print("  python celery_analyzer.py --create-sample")
        print("  python celery_analyzer.py --db-stats")
        print("  python celery_analyzer.py --get-latest AAPL")
        sys.exit(1)
    
    analyzer = CeleryEnabledMeanReversionAnalyzer()
    
    # Handle special commands
    if sys.argv[1] == "--create-sample":
        analyzer.create_sample_files()
        return
    
    if sys.argv[1] == "--db-stats":
        analyzer.print_database_summary()
        return
    
    if sys.argv[1] == "--cleanup-db":
        days = int(sys.argv[2]) if len(sys.argv) > 2 else 90
        result = analyzer.cleanup_old_data(days)
        if 'error' in result:
            print(f"Cleanup failed: {result['error']}")
        else:
            print(f"Cleanup completed: {result}")
        return
    
    if sys.argv[1] == "--get-latest":
        if len(sys.argv) < 3:
            print("Please provide a stock symbol")
            sys.exit(1)
        symbol = sys.argv[2].upper()
        result = analyzer.get_latest_stock_analysis(symbol)
        if 'error' in result:
            print(f"Error: {result['error']}")
        else:
            print(f"Latest analysis for {symbol}:")
            print(f"  Price: ${result.get('current_price', 'N/A')}")
            print(f"  Z-Score: {result.get('z_score', 'N/A')}")
            print(f"  RSI: {result.get('rsi', 'N/A')}")
            print(f"  Condition: {result.get('market_condition', 'N/A')}")
            print(f"  Action: {result.get('action', 'N/A')}")
        return
    
    if sys.argv[1] == "--get-oversold":
        results = analyzer.get_signals_by_condition('OVERSOLD')
        print(f"Found {len(results)} oversold signals:")
        for r in results[:10]:  # Show first 10
            print(f"  {r['symbol']}: Z-Score {r['z_score']:.2f}, RSI {r['rsi']:.1f}")
        return
    
    if sys.argv[1] == "--get-overbought":
        results = analyzer.get_signals_by_condition('OVERBOUGHT')
        print(f"Found {len(results)} overbought signals:")
        for r in results[:10]:  # Show first 10
            print(f"  {r['symbol']}: Z-Score {r['z_score']:.2f}, RSI {r['rsi']:.1f}")
        return
    
    if sys.argv[1] == "--get-high-conf":
        results = analyzer.get_high_confidence_signals()
        print(f"Found {len(results)} high confidence recommendations:")
        for r in results[:10]:  # Show first 10
            print(f"  {r['symbol']}: {r['action']} (Z-Score {r['z_score']:.2f})")
        return
    
    # Parse regular analysis options
    stock_file = sys.argv[1]
    show_progress = "--no-progress" not in sys.argv
    save_csv = "--no-csv" not in sys.argv
    save_to_db = "--no-db" not in sys.argv
    
    # Create analyzer and run analysis
    try:
        signals = analyzer.run_analysis(
            stock_file=stock_file,
            show_progress=show_progress,
            save_csv=save_csv,
            save_to_db=save_to_db
        )
        
        print(f"\nAnalysis completed successfully!")
        print(f"Found {len(signals)} mean reversion signals.")
        
        if analyzer.enable_db and save_to_db:
            print("Results saved to database via Celery tasks.")
        
    except KeyboardInterrupt:
        print("\nAnalysis interrupted by user.")
        sys.exit(1)
    except Exception as e:
        print(f"\nError during analysis: {e}")
        logging.error(f"Analysis failed: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
